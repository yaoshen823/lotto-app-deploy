<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大樂透分析顧問</title>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 載入 SheetJS (用於 Excel 檔案 I/O) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <script type="module">
        // Module Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, onSnapshot, setDoc, doc, deleteDoc, writeBatch, getDocs, limit, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Tailwind Configuration
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Noto Sans TC', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#DC2626', 
                        'secondary': '#FACC15', 
                        'dark-bg': '#1F2937', 
                        'card-bg': '#374151', 
                        'genius': '#4F46E5', // Indigo for Genius
                        'ai': '#06B6D4', // Cyan for AI
                        'extreme': '#EF4444', // Red for Extreme
                        'markov': '#84CC16', // Lime Green for Markov
                    }
                }
            }
        }
        
        // --- 全局變數 ---
        let db = null;
        let auth = null;
        let userId = 'loading'; 
        let isAuthReady = false;
        let dataStore = [];
        let unsubscribe = () => {}; 
        let currentEditingId = null; 
        let COLLECTION_PATH = '';
        const MARKOV_WINDOW = 10; // 馬可夫鏈計算窗口：近 10 期

        // 初始數據集 (78 筆 2025 年紀錄 - 確保格式統一)
        const initialLottoData = [
            {"drawId": "114000001", "date": "01/03", "main": [6, 9, 15, 29, 30, 48], "special": 23},
            {"drawId": "114000002", "date": "01/07", "main": [1, 8, 20, 26, 29, 35], "special": 19},
            {"drawId": "114000003", "date": "01/10", "main": [14, 29, 35, 36, 37, 49], "special": 40},
            {"drawId": "114000004", "date": "01/14", "main": [1, 3, 13, 15, 37, 48], "special": 42},
            {"drawId": "114000005", "date": "01/17", "main": [11, 18, 32, 39, 44, 49], "special": 46},
            {"drawId": "114000006", "date": "01/21", "main": [6, 21, 35, 36, 38, 42], "special": 22},
            {"drawId": "114000007", "date": "01/24", "main": [6, 22, 23, 30, 36, 37], "special": 13},
            {"drawId": "114000008", "date": "01/28", "main": [2, 17, 19, 21, 23, 39], "special": 38},
            {"drawId": "114000009", "date": "01/31", "main": [4, 11, 19, 21, 38, 43], "special": 1},
            {"drawId": "114000010", "date": "02/04", "main": [10, 15, 17, 28, 41, 48], "special": 45},
            {"drawId": "114000011", "date": "02/07", "main": [1, 10, 11, 31, 33, 44], "special": 43},
            {"drawId": "114000012", "date": "02/11", "main": [12, 16, 24, 27, 34, 49], "special": 36},
            {"drawId": "114000013", "date": "02/14", "main": [7, 12, 18, 23, 27, 30], "special": 41},
            {"drawId": "114000014", "date": "02/18", "main": [5, 11, 13, 16, 33, 39], "special": 46},
            {"drawId": "114000015", "date": "02/21", "main": [3, 22, 28, 36, 39, 43], "special": 35},
            {"drawId": "114000016", "date": "02/25", "main": [10, 20, 27, 32, 41, 44], "special": 47},
            {"drawId": "114000017", "date": "02/28", "main": [15, 23, 26, 30, 40, 44], "special": 1},
            {"drawId": "114000018", "date": "03/03", "main": [7, 8, 11, 18, 34, 49], "special": 15},
            {"drawId": "114000019", "date": "03/06", "main": [4, 15, 21, 23, 30, 42], "special": 32},
            {"drawId": "114000020", "date": "03/10", "main": [1, 12, 16, 21, 37, 40], "special": 47},
            {"drawId": "114000021", "date": "03/13", "main": [3, 11, 25, 28, 33, 46], "special": 2},
            {"drawId": "114000022", "date": "03/17", "main": [2, 10, 14, 25, 29, 39], "special": 38},
            {"drawId": "114000023", "date": "03/20", "main": [5, 6, 22, 24, 31, 41], "special": 18},
            {"drawId": "114000024", "date": "03/24", "main": [10, 13, 26, 29, 32, 42], "special": 14},
            {"drawId": "114000025", "date": "03/27", "main": [1, 5, 18, 22, 38, 48], "special": 44},
            {"drawId": "114000026", "date": "03/31", "main": [13, 27, 33, 39, 45, 46], "special": 19},
            {"drawId": "114000027", "date": "04/04", "main": [7, 20, 29, 40, 43, 47], "special": 28},
            {"drawId": "114000028", "date": "04/08", "main": [10, 26, 33, 39, 45, 46], "special": 19},
            {"drawId": "114000029", "date": "04/11", "main": [6, 10, 11, 17, 23, 32], "special": 27},
            {"drawId": "114000030", "date": "04/15", "main": [18, 28, 37, 41, 43, 46], "special": 11},
            {"drawId": "114000031", "date": "04/18", "main": [2, 8, 15, 22, 29, 45], "special": 9},
            {"drawId": "114000032", "date": "04/22", "main": [1, 6, 14, 19, 35, 49], "special": 8},
            {"drawId": "114000033", "date": "04/25", "main": [20, 21, 24, 25, 31, 35], "special": 28},
            {"drawId": "114000034", "date": "04/29", "main": [7, 11, 24, 26, 30, 42], "special": 37},
            {"drawId": "114000035", "date": "05/02", "main": [2, 5, 39, 43, 45, 47], "special": 26},
            {"drawId": "114000036", "date": "05/06", "main": [5, 8, 9, 25, 30, 45], "special": 31},
            {"drawId": "114000037", "date": "05/09", "main": [15, 27, 33, 42, 48, 49], "special": 39},
            {"drawId": "114000038", "date": "05/13", "main": [1, 23, 29, 41, 45, 49], "special": 24},
            {"drawId": "114000039", "date": "05/16", "main": [13, 16, 22, 23, 34, 39], "special": 14},
            {"drawId": "114000040", "date": "05/20", "main": [2, 11, 15, 26, 29, 48], "special": 31},
            {"drawId": "114000041", "date": "05/23", "main": [1, 7, 11, 24, 44, 48], "special": 10},
            {"drawId": "114000042", "date": "05/27", "main": [16, 17, 26, 29, 32, 40], "special": 10},
            {"drawId": "114000043", "date": "05/30", "main": [3, 4, 13, 21, 38, 46], "special": 2},
            {"drawId": "114000044", "date": "06/03", "main": [9, 24, 32, 40, 41, 49], "special": 27},
            {"drawId": "114000045", "date": "06/06", "main": [11, 13, 15, 39, 42, 46], "special": 28},
            {"drawId": "114000046", "date": "06/10", "main": [3, 5, 12, 16, 22, 48], "special": 30},
            {"drawId": "114000047", "date": "06/13", "main": [1, 2, 10, 13, 20, 27], "special": 49},
            {"drawId": "114000048", "date": "06/17", "main": [13, 20, 21, 26, 31, 44], "special": 28},
            {"drawId": "114000049", "date": "06/20", "main": [4, 20, 31, 40, 42, 48], "special": 24},
            {"drawId": "114000050", "date": "06/24", "main": [3, 8, 20, 37, 45, 49], "special": 21},
            {"drawId": "114000051", "date": "06/27", "main": [4, 8, 9, 14, 21, 39], "special": 37},
            {"drawId": "114000052", "date": "07/01", "main": [8, 9, 21, 25, 33, 34], "special": 2},
            {"drawId": "114000053", "date": "07/04", "main": [5, 13, 15, 18, 33, 37], "special": 45},
            {"drawId": "114000054", "date": "07/08", "main": [6, 8, 12, 14, 25, 35], "special": 49},
            {"drawId": "114000055", "date": "07/11", "main": [15, 16, 26, 34, 48, 49], "special": 46},
            {"drawId": "114000056", "date": "07/15", "main": [32, 33, 41, 45, 46, 49], "special": 10},
            {"drawId": "114000057", "date": "07/18", "main": [2, 25, 36, 37, 38, 46], "special": 24},
            {"drawId": "114000058", "date": "07/22", "main": [5, 17, 19, 26, 27, 39], "special": 10},
            {"drawId": "114000059", "date": "07/25", "main": [2, 4, 23, 35, 41, 47], "special": 6},
            {"drawId": "114000060", "date": "07/29", "main": [2, 5, 14, 19, 36, 45], "special": 43},
            {"drawId": "114000061", "date": "08/01", "main": [4, 14, 19, 28, 40, 41], "special": 31},
            {"drawId": "114000062", "date": "08/05", "main": [1, 20, 34, 36, 37, 40], "special": 3},
            {"drawId": "114000063", "date": "08/08", "main": [11, 16, 17, 21, 24, 29], "special": 34},
            {"drawId": "114000064", "date": "08/12", "main": [6, 7, 15, 22, 37, 42], "special": 36},
            {"drawId": "114000065", "date": "08/15", "main": [3, 5, 7, 15, 17, 47], "special": 34},
            {"drawId": "114000066", "date": "08/19", "main": [2, 23, 25, 33, 41, 46], "special": 22},
            {"drawId": "114000067", "date": "08/22", "main": [23, 33, 38, 43, 45, 47], "special": 36},
            {"drawId": "114000068", "date": "08/26", "main": [3, 6, 22, 32, 35, 39], "special": 27},
            {"drawId": "114000069", "date": "08/29", "main": [13, 20, 25, 27, 28, 32], "special": 2},
            {"drawId": "114000070", "date": "09/02", "main": [2, 6, 9, 19, 20, 30], "special": 25},
            {"drawId": "114000071", "date": "09/05", "main": [10, 13, 14, 17, 19, 29], "special": 40},
            {"drawId": "114000072", "date": "09/09", "main": [12, 20, 25, 26, 40, 45], "special": 34},
            {"drawId": "114000073", "date": "09/12", "main": [2, 3, 4, 11, 15, 41], "special": 26},
            {"drawId": "114000074", "date": "09/16", "main": [7, 17, 18, 22, 25, 47], "special": 38},
            {"drawId": "114000075", "date": "09/19", "main": [14, 17, 26, 36, 38, 41], "special": 8},
            {"drawId": "114000076", "date": "09/23", "main": [5, 14, 22, 25, 27, 45], "special": 3},
            {"drawId": "114000077", "date": "09/26", "main": [1, 2, 25, 29, 41, 49], "special": 35},
            {"drawId": "114000078", "date": "09/30", "main": [19, 20, 22, 32, 36, 42], "special": 35}
        ];
        
        // --- 設定您自己的 Firebase Config ---
        const EXTERNAL_FIREBASE_CONFIG = {
            apiKey: "AIzaSyC0GlNeFeV5_R05imC1OWmyNdP1OR2c6MI",
            authDomain: "lotto-analyzer-e424e.firebaseapp.com",
            projectId: "lotto-analyzer-e424e",
            storageBucket: "lotto-analyzer-e424e.firebasestorage.app",
            messagingSenderId: "932809120947",
            appId: "1:932809120947:web:b2dc105adff390c31ba4c6",
            measurementId: "G-PESKZ6YGT1"
        };
        
        // --- 核心初始化流程 (保持不變) ---

        async function initializeFirebase() {
            const errorDisplay = document.getElementById('error-display');
            const loadingIndicator = document.getElementById('loading-indicator');
            const mainContent = document.getElementById('main-content');
            
            errorDisplay.classList.add('hidden');

            try {
                let config = EXTERNAL_FIREBASE_CONFIG;
                let appIdForPath = config.projectId || 'external-app';

                if (typeof __firebase_config !== 'undefined' && __firebase_config) {
                    config = JSON.parse(__firebase_config);
                    appIdForPath = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                } else if (config.apiKey === "YOUR_FIREBASE_API_KEY") {
                    throw new Error("配置錯誤：請將程式碼中的 'YOUR_FIREBASE_API_KEY' 替換為您個人的 Firebase 專案配置。");
                } 

                if (!config || !config.apiKey) {
                    throw new Error("Firebase configuration is missing or invalid.");
                }

                const app = initializeApp(config);
                db = getFirestore(app);
                auth = getAuth(app);
                
                setLogLevel('debug');
                COLLECTION_PATH = `artifacts/${appIdForPath}/public/data/lotto_draws`;
                
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth); 
                }

                userId = auth.currentUser?.uid || 'anonymous';
                isAuthReady = true;

                await seedInitialData();
                setupRealtimeListener();
                
                document.getElementById('add-result-form').addEventListener('submit', handleAddResult);
                document.getElementById('export-data-btn').addEventListener('click', exportData);
                document.getElementById('import-file-input').addEventListener('change', importData);
                document.getElementById('backtest-run-btn').addEventListener('click', runBacktest);

                
                loadingIndicator.classList.add('hidden');
                mainContent.classList.remove('hidden');
               // document.getElementById('user-id-display').textContent = `User ID: ${userId} (Collection: ${COLLECTION_PATH})`;

                // 渲染 Lucide Icons
                lucide.createIcons();
                // 填充回溯測試期別選擇
                fillBacktestSelector();

            } catch (error) {
                console.error("Firebase 啟動失敗:", error);
                loadingIndicator.classList.add('hidden');
                mainContent.classList.add('hidden');
                
                errorDisplay.innerHTML = `
                    <div class="p-6 rounded-xl shadow-2xl bg-red-900/40 border-l-4 border-red-500 max-w-xl mx-auto mt-20">
                        <p class="text-xl font-bold text-red-300">❌ 應用程式啟動失敗</p>
                        <p class="text-sm mt-2 text-red-200">錯誤訊息: ${error.message}</p>
                        <p class="text-sm mt-4 text-yellow-300">
                           <span class="font-bold">部署提示:</span> 
                           請確保您已替換 <code class="bg-gray-700 p-1 rounded">EXTERNAL_FIREBASE_CONFIG</code>。
                        </p>
                    </div>`;
                errorDisplay.classList.remove('hidden');
            }
        }
        
        async function seedInitialData() {
            try {
                if (!db) return;
                const q = query(collection(db, COLLECTION_PATH), limit(1));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    const batch = writeBatch(db);
                    initialLottoData.forEach(record => {
                        const docRef = doc(db, COLLECTION_PATH, record.drawId);
                        batch.set(docRef, {
                            ...record,
                            date: record.date.toString().trim(), 
                            timestamp: serverTimestamp() 
                        });
                    });
                    await batch.commit();
                }
            } catch (error) {
                console.error("寫入初始數據失敗:", error);
            }
        }


        function setupRealtimeListener() {
            unsubscribe(); 
            
            if (!db || !isAuthReady) return;
            
            if (currentEditingId) {
                currentEditingId = null;
            }
            
            const q = query(collection(db, COLLECTION_PATH), orderBy('drawId', 'desc'));

            unsubscribe = onSnapshot(q, (snapshot) => {
                const records = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    records.push({
                        ...data,
                        drawId: doc.id, 
                    });
                });
                dataStore = records;
                dataStore.sort((a, b) => b.drawId.localeCompare(a.drawId)); // 確保最新的在前面
                processAndRenderData(dataStore);
                fillBacktestSelector();
                
            }, (error) => {
                console.error("實時監聽錯誤:", error);
                document.getElementById('form-message').textContent = `❌ 實時數據更新失敗: ${error.message}`;
                document.getElementById('form-message').classList.remove('hidden', 'text-green-500', 'bg-green-900/50');
                document.getElementById('form-message').classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
            });
        }
        
        // --- 天才策略核心計算 (保持不變) ---
        function calculateGeniusScore(records) {
            const geniusScoreMap = new Map();
            const numRange = Array.from({ length: 49 }, (_, i) => i + 1);
            numRange.forEach(n => geniusScoreMap.set(n, 0));

            const transitionMatrix = new Array(50).fill(0).map(() => new Array(50).fill(0));
            const totalTransitions = new Array(50).fill(0);

            for (let i = 0; i < records.length - 1; i++) {
                const currentDraw = records[i].main;
                const nextDraw = records[i+1].main; 

                for (const num_i of currentDraw) {
                    totalTransitions[num_i]++;
                    for (const num_j of nextDraw) {
                        transitionMatrix[num_i][num_j]++;
                    }
                }
            }
            
            const LAMBDA = 0.5; 
            const AVERAGE_NEXT_APPEARANCE = 6 * 6 / 49; 

            for (const targetNum of numRange) {
                let score = 0;
                for (const predictorNum of numRange) {
                    const count = transitionMatrix[predictorNum][targetNum];
                    const countRatio = totalTransitions[predictorNum] > 0 ? count / totalTransitions[predictorNum] : 0;
                    
                    const beta = countRatio - (AVERAGE_NEXT_APPEARANCE / 49);
                    
                    const penalizedBeta = beta / (1 + LAMBDA * totalTransitions[predictorNum]);

                    score += penalizedBeta; 
                }
                
                const mod7Penalty = (targetNum % 7 === 1 || targetNum % 7 === 3 || targetNum % 7 === 5) ? -0.1 : 0;

                geniusScoreMap.set(targetNum, score + mod7Penalty);
            }

            const sortedGeniusScore = Array.from(geniusScoreMap.entries())
                .sort((a, b) => b[1] - a[1]);

            return sortedGeniusScore;
        }

        // --- 馬可夫鏈策略核心計算 (NEW) ---
        function calculateMarkovTendency(records) {
            const numRange = Array.from({ length: 49 }, (_, i) => i + 1);
            const transitionScores = new Map();

            // 僅使用近 MARKOV_WINDOW 期的數據
            const localRecords = records.slice(0, MARKOV_WINDOW);

            if (localRecords.length < 2) return numRange.map(n => [n, 0]);

            // [i] 號碼出現後，[j] 號碼在下一期出現的次數
            const localTransitionMatrix = new Array(50).fill(0).map(() => new Array(50).fill(0));
            const localTotalTransitions = new Array(50).fill(0);

            for (let i = 0; i < localRecords.length - 1; i++) {
                const currentDraw = localRecords[i].main;
                const nextDraw = localRecords[i+1].main; 

                for (const num_i of currentDraw) {
                    localTotalTransitions[num_i]++;
                    for (const num_j of nextDraw) {
                        localTransitionMatrix[num_i][num_j]++;
                    }
                }
            }

            // 計算每個號碼的「被傳導得分」：即它被所有剛開出的號碼帶出來的機率總和
            for (const targetNum of numRange) {
                let score = 0;
                
                // 每個已開出的號碼對 targetNum 的條件機率 P(targetNum | predictorNum)
                for (const predictorNum of numRange) {
                    const count = localTransitionMatrix[predictorNum][targetNum];
                    if (localTotalTransitions[predictorNum] > 0) {
                        // 條件機率 P(Y | X)
                        const conditionalProb = count / localTotalTransitions[predictorNum];
                        score += conditionalProb; 
                    }
                }
                transitionScores.set(targetNum, score);
            }

            // 排序結果
            const sortedMarkovScores = Array.from(transitionScores.entries())
                .sort((a, b) => b[1] - a[1]);

            return sortedMarkovScores;
        }


        // --- 核心分析邏輯 (可重複使用，用於即時和回溯) ---
        
        function runAnalysis(records) {
            if (records.length === 0) return {};

            const freqMap = new Map();
            const weightedFreqMap = new Map();
            const gapMap = new Map();
            const cooccurrenceMap = new Map();
            const consecutiveCount = new Map(); 
            const parityCount = new Map();       

            const numRange = Array.from({ length: 49 }, (_, i) => i + 1);
            let drawIndex = 0; 

            numRange.forEach(n => {
                freqMap.set(n, 0);
                weightedFreqMap.set(n, 0);
                gapMap.set(n, records.length); 
            });

            for (const record of records) {
                if (!record.main || !Array.isArray(record.main) || record.main.length !== 6 || isNaN(record.special)) continue;

                const allNumbers = [...record.main, record.special];
                const mainNumbers = record.main.slice().sort((a, b) => a - b);
                
                const weight = (records.length - drawIndex) / records.length; 

                // --- 1. 頻率與共現分析 ---
                for (const num of allNumbers) {
                    freqMap.set(num, (freqMap.get(num) || 0) + 1);
                    if (record.main.includes(num)) {
                        weightedFreqMap.set(num, weightedFreqMap.get(num) + weight);
                    }
                    if (gapMap.get(num) === records.length) {
                        gapMap.set(num, drawIndex);
                    }
                }

                for (let i = 0; i < mainNumbers.length; i++) {
                    for (let j = i + 1; j < mainNumbers.length; j++) {
                        const pair = `${mainNumbers[i].toString().padStart(2, '0')},${mainNumbers[j].toString().padStart(2, '0')}`;
                        cooccurrenceMap.set(pair, (cooccurrenceMap.get(pair) || 0) + 1);
                    }
                }
                
                // --- 2. 組合傾向分析 ---
                let consecutiveSets = 0;
                let oddCount = 0;
                
                for (let i = 0; i < mainNumbers.length; i++) {
                    if (i > 0 && mainNumbers[i] === mainNumbers[i-1] + 1) {
                        if (i === 1 || mainNumbers[i-2] !== mainNumbers[i-1] - 1) {
                            consecutiveSets++;
                        }
                    }
                    if (mainNumbers[i] % 2 !== 0) {
                        oddCount++;
                    }
                }
                
                const evenCount = 6 - oddCount;
                const parityKey = `${oddCount}:${evenCount}`;
                const consecutiveKey = consecutiveSets.toString();
                
                parityCount.set(parityKey, (parityCount.get(parityKey) || 0) + 1);
                consecutiveCount.set(consecutiveKey, (consecutiveCount.get(consecutiveKey) || 0) + 1);
                
                drawIndex++;
            }

            const sortedFreq = Array.from(freqMap.entries()).filter(([num]) => num <= 49 && freqMap.get(num) > 0).sort((a, b) => b[1] - a[1]);
            const sortedWeighted = Array.from(weightedFreqMap.entries()).filter(([num]) => num <= 49 && weightedFreqMap.get(num) > 0).sort((a, b) => b[1] - a[1]);
            const sortedCooccurrence = Array.from(cooccurrenceMap.entries()).sort((a, b) => b[1] - a[1]);
            const sortedGap = Array.from(gapMap.entries()).filter(([num]) => num <= 49).sort((a, b) => b[1] - a[1]);
            const sortedParity = Array.from(parityCount.entries()).sort((a, b) => b[1] - a[1]);
            const sortedConsecutive = Array.from(consecutiveCount.entries()).sort((a, b) => b[1] - a[1]);
            
            const sortedGeniusScore = calculateGeniusScore(records);
            const sortedMarkovScores = calculateMarkovTendency(records);

            const combinationStats = {
                bestParity: sortedParity[0] ? sortedParity[0][0] : '3:3',
                worstParity: sortedParity.length > 1 ? sortedParity[sortedParity.length - 1][0] : '6:0',
                bestConsecutive: sortedConsecutive[0] ? sortedConsecutive[0][0] : '1',
                worstConsecutive: sortedConsecutive.length > 1 ? sortedConsecutive[sortedConsecutive.length - 1][0] : '3',
                parityDistribution: sortedParity,
                consecutiveDistribution: sortedConsecutive,
            };

            return { sortedFreq, sortedWeighted, sortedGap, sortedCooccurrence, combinationStats, sortedGeniusScore, sortedMarkovScores };
        }

        function processAndRenderData(records) {
            if (records.length === 0) {
                // ... (處理無數據的渲染邏輯)
                document.getElementById('prediction-results').innerHTML = '<p class="text-center text-gray-400 p-4">無歷史紀錄，無法進行分析。</p>';
                document.getElementById('backtest-selector').innerHTML = '<option value="">無足夠紀錄進行回溯測試</option>';
                return;
            }

            const analysis = runAnalysis(records);
            
            if (!analysis.sortedFreq) {
                 document.getElementById('prediction-results').innerHTML = '<p class="text-center text-red-400 p-4">所有紀錄皆無效或格式錯誤，無法進行分析。</p>';
                return;
            }

            const predictions = generatePredictions(analysis);
            renderStats(records, analysis.sortedFreq.slice(0, 10), analysis.sortedWeighted.slice(0, 10), analysis.sortedCooccurrence.slice(0, 10), analysis.combinationStats, predictions);
            // 渲染 Lucide Icons
            lucide.createIcons();
        }
        
        // --- 預測生成邏輯 (更新為 5 個策略 - 移除策略二，新增策略六) ---
        function generatePredictions({ sortedWeighted, sortedFreq, sortedGap, combinationStats, sortedGeniusScore, sortedMarkovScores }) {
            
            const safePick = (sourceArray, existingSet, n) => {
                const picked = [];
                const localSet = new Set(existingSet);
                let available = sourceArray.map(item => Array.isArray(item) ? item[0] : item).filter(num => !localSet.has(num));

                const pickFromRange = (arr, count) => arr.sort(() => 0.5 - Math.random()).slice(0, count);

                const ranges = { low: [], mid: [], high: [] };
                available.forEach(num => {
                    if (num >= 1 && num <= 16) ranges.low.push(num);
                    else if (num >= 17 && num <= 32) ranges.mid.push(num);
                    else if (num >= 33 && num <= 49) ranges.high.push(num);
                });

                const pickBalanced = () => {
                    let picks = [];
                    const order = ['low', 'mid', 'high'].sort(() => 0.5 - Math.random());
                    let needed = n;
                    
                    for (const range of order) {
                        let count = Math.min(Math.ceil(needed / (order.length - picks.length)), ranges[range].length);
                        picks.push(...pickFromRange(ranges[range], count));
                        needed = n - picks.length;
                        if (needed === 0) break;
                    }
                    return picks;
                };

                const picks = pickBalanced();
                return picks.slice(0, n);
            };

            const generateSpecialPicks = (mainNumbers) => {
                 const mainSet = new Set(mainNumbers);
                const candidates = sortedFreq
                    .slice(0, 15) 
                    .map(([num]) => num)
                    .filter(num => num <= 49 && !mainSet.has(num))
                    .sort(() => 0.5 - Math.random());

                const specialPicks = candidates.slice(0, 3).map(n => n.toString().padStart(2, '0'));
                
                while (specialPicks.length < 3) {
                    const rand = Math.floor(Math.random() * 49) + 1;
                    if (!mainSet.has(rand) && !specialPicks.includes(rand.toString().padStart(2, '0'))) {
                        specialPicks.push(rand.toString().padStart(2, '0'));
                    }
                }
                return specialPicks.slice(0, 3).join(', ');
            }
            
            const checkConsecutive = (set) => set.map(Number).reduce((count, n, i, arr) => {
                if (i > 0 && n === arr[i-1] + 1) {
                    if (i === 1 || arr[i-2] !== n - 2) {
                        count++;
                    }
                }
                return count;
            }, 0);
            
            const MAX_ITERATIONS = 50;
            const targetOdd = combinationStats.bestParity.split(':').map(Number)[0];


            // --- 策略一：熱門號優選 (穩健型) ---
            let set1 = [];
            let iterations1 = 0;
            
            while (set1.length !== 6 && iterations1 < MAX_ITERATIONS) {
                const hotCandidates = sortedWeighted.slice(0, 15); 
                set1 = safePick(hotCandidates, new Set(), 6);
                const currentOdd = set1.filter(n => n % 2 !== 0).length;
                if (Math.abs(currentOdd - targetOdd) <= 1 && (new Set(set1)).size === 6) break; 
                iterations1++;
            }
            if ((new Set(set1)).size !== 6) {
                set1 = Array.from(new Set(set1)).slice(0, 6);
                while (set1.length < 6) { const rand = Math.floor(Math.random() * 49) + 1; if (!set1.includes(rand)) set1.push(rand); }
            }
            set1 = set1.slice(0, 6).sort((a, b) => a - b).map(n => n.toString().padStart(2, '0'));
            const finalOddCount1 = set1.map(Number).filter(n => n % 2 !== 0).length;
            const special1 = generateSpecialPicks(set1.map(Number));

            // --- 策略二 (原策略三)：最大熵/反向模式 (極端型) ---
            let set2 = [];
            const coldCandidates2 = sortedGap.slice(0, 15); 
            const worstOdd = combinationStats.worstParity.split(':').map(Number)[0];
            let iterations2 = 0;
            
            while (set2.length !== 6 && iterations2 < MAX_ITERATIONS) {
                set2 = safePick(coldCandidates2, new Set(), 6);
                const currentOdd = set2.filter(n => n % 2 !== 0).length;
                if (Math.abs(currentOdd - worstOdd) <= 1 && (new Set(set2)).size === 6) break; 
                iterations2++;
            }
            if ((new Set(set2)).size !== 6) {
                set2 = Array.from(new Set(set2)).slice(0, 6);
                while (set2.length < 6) { const rand = Math.floor(Math.random() * 49) + 1; if (!set2.includes(rand)) set2.push(rand); }
            }
            set2 = set2.slice(0, 6).sort((a, b) => a - b).map(n => n.toString().padStart(2, '0'));
            const finalOddCount2 = set2.map(Number).filter(n => n % 2 !== 0).length;
            const special2 = generateSpecialPicks(set2.map(Number));

            // --- 策略三 (原策略四)：AI 適應性模式與極端分散 ---
            const aiCandidates = sortedGeniusScore.slice(0, 15).map(item => item[0]); // 使用GeniusScore作為AI潛力池
            let set3 = [];
            let currentBestDispersion = 0;
            
            for (let i = 0; i < MAX_ITERATIONS * 2; i++) {
                const combo = safePick(aiCandidates.map(n => [n]), new Set(), 6);
                if (combo.length !== 6) continue;

                const sortedCombo = combo.sort((a, b) => a - b);
                
                let minGap = 49;
                for (let j = 1; j < sortedCombo.length; j++) {
                    minGap = Math.min(minGap, sortedCombo[j] - sortedCombo[j-1]);
                }

                if (minGap > currentBestDispersion) {
                    set3 = combo;
                    currentBestDispersion = minGap;
                }
            }
            
            if (set3.length !== 6) {
                set3 = safePick(aiCandidates.map(n => [n]), new Set(), 6);
                while (set3.length < 6) { const rand = Math.floor(Math.random() * 49) + 1; if (!set3.includes(rand)) set3.push(rand); }
            }

            set3 = set3.slice(0, 6).sort((a, b) => a - b).map(n => n.toString().padStart(2, '0'));
            const finalOddCount3 = set3.map(Number).filter(n => n % 2 !== 0).length;
            const special3 = generateSpecialPicks(set3.map(Number));
            
            // --- 策略四 (原策略五)：天才的巴布隆迴歸 ---
            const geniusCandidates = sortedGeniusScore.slice(0, 10).map(item => item[0]); 
            let set4 = [];
            
            let iterations4 = 0;
            
            while (set4.length !== 6 && iterations4 < MAX_ITERATIONS) {
                const candidates = [...geniusCandidates];
                set4 = safePick(candidates, new Set(), 6);
                
                const hasEvenMod7 = set4.filter(n => (n % 7 === 0 || n % 7 === 2 || n % 7 === 4 || n % 7 === 6)).length;
                const currentOdd = set4.filter(n => n % 2 !== 0).length;

                if (hasEvenMod7 >= 3 && Math.abs(currentOdd - targetOdd) <= 1 && (new Set(set4)).size === 6) break; 
                iterations4++;
            }
            if ((new Set(set4)).size !== 6) {
                set4 = safePick(geniusCandidates, new Set(), 6);
                while (set4.length < 6) { const rand = Math.floor(Math.random() * 49) + 1; if (!set4.includes(rand)) set4.push(rand); }
            }
            
            set4 = set4.slice(0, 6).sort((a, b) => a - b).map(n => n.toString().padStart(2, '0'));
            const finalOddCount4 = set4.map(Number).filter(n => n % 2 !== 0).length;
            const special4 = generateSpecialPicks(set4.map(Number));

            // --- 策略五：局部馬可夫熱區 (NEW LMT) ---
            const markovCandidates = sortedMarkovScores.slice(0, 15).map(item => item[0]);
            let set5 = [];
            let iterations5 = 0;
            
            while (set5.length !== 6 && iterations5 < MAX_ITERATIONS) {
                set5 = safePick(markovCandidates.map(n => [n]), new Set(), 6);
                const currentOdd = set5.filter(n => n % 2 !== 0).length;
                if (Math.abs(currentOdd - targetOdd) <= 1 && (new Set(set5)).size === 6) break; 
                iterations5++;
            }
            if ((new Set(set5)).size !== 6) {
                set5 = safePick(markovCandidates.map(n => [n]), new Set(), 6);
                while (set5.length < 6) { const rand = Math.floor(Math.random() * 49) + 1; if (!set5.includes(rand)) set5.push(rand); }
            }

            set5 = set5.slice(0, 6).sort((a, b) => a - b).map(n => n.toString().padStart(2, '0'));
            const finalOddCount5 = set5.map(Number).filter(n => n % 2 !== 0).length;
            const special5 = generateSpecialPicks(set5.map(Number));


            // --- 總結所有策略 ---

            return [
                {
                    id: 'S1', name: "策略一：熱門號優選", subtitle: "穩健的主流趨勢", icon: 'TrendingUp', color: 'secondary',
                    numbers: set1.join(', '), special: special1,
                    basis: `基於近期加權熱門號碼池，並強制優化組合，使其奇偶比接近歷史最常見的 **${combinationStats.bestParity}**。`,
                    metrics: `奇偶比: ${finalOddCount1}:${6-finalOddCount1} | 連號數: ${checkConsecutive(set1)} 組`
                },
                {
                    id: 'S2', name: "策略二：最大熵/反向模式", subtitle: "極端冷門的回補賭注", icon: 'Ghost', color: 'extreme',
                    numbers: set2.join(', '), special: special2,
                    basis: `專注於**間隔最長**的冷門號碼，並依據歷史最不常見的**奇偶比 (${combinationStats.worstParity})** 來構建組合。`,
                    metrics: `奇偶比: ${finalOddCount2}:${6-finalOddCount2} | 連號數: ${checkConsecutive(set2)} 組`
                },
                {
                    id: 'S3', name: "策略三：AI 智慧型", subtitle: "計算分佈的適應性", icon: 'Bot', color: 'ai',
                    numbers: set3.join(', '), special: special3,
                    basis: `由 AI 結合「鄰近活躍度」與「冷熱間隔」篩選潛力號碼，並最大化六個號碼在 1-49 範圍內的**分佈分散度**。`,
                    metrics: `奇偶比: ${finalOddCount3}:${6-finalOddCount3} | 連號數: ${checkConsecutive(set3)} 組`
                },
                {
                    id: 'S4', name: "策略四：天才的巴布隆迴歸", subtitle: "隱藏結構的複雜預測", icon: 'BrainCircuit', color: 'genius',
                    numbers: set4.join(', '), special: special4,
                    basis: `採用 L2 正則化的貝葉斯迴歸變種，基於號碼的**跨期條件影響力**來選擇。專注於**高貢獻度**和**反世俗週期**的號碼。`,
                    metrics: `奇偶比: ${finalOddCount4}:${6-finalOddCount4} | 連號數: ${checkConsecutive(set4)} 組`
                },
                 {
                    id: 'S5', name: "策略五：局部馬可夫熱區", subtitle: "短期連動的傳導效應", icon: 'Zap', color: 'markov',
                    numbers: set5.join(', '), special: special5,
                    basis: `基於近 ${MARKOV_WINDOW} 期的局部馬可夫鏈，選擇**被剛開出號碼「傳導」機率最高**的潛力號碼組。`,
                    metrics: `奇偶比: ${finalOddCount5}:${6-finalOddCount5} | 連號數: ${checkConsecutive(set5)} 組`
                }
            ];
        }

        // --- 渲染統計數據 ---
        function renderStats(records, sortedFreq, sortedWeighted, sortedCooccurrence, comboStats, predictions) {
            
            const formatComboStats = (dist) => dist.map(([key, count]) => `
                <div class="flex justify-between items-center text-sm">
                    <span class="font-medium w-1/3">${key}</span>
                    <span class="w-2/3 text-right text-gray-300">${count} 次</span>
                </div>
            `).join('');

            document.getElementById('combo-stats').innerHTML = `
                <div class="space-y-4">
                    <div class="border-b border-card-bg/50 pb-3">
                        <h4 class="text-base font-semibold text-secondary">🥇 最佳奇偶比 / 🎯 最差奇偶比</h4>
                        <p class="text-xl font-extrabold text-primary">${comboStats.bestParity} <span class="text-gray-400">/</span> ${comboStats.worstParity}</p>
                        <div class="mt-2 text-sm text-gray-400">
                           ${formatComboStats(comboStats.parityDistribution.slice(0, 5))}
                        </div>
                    </div>
                    <div>
                        <h4 class="text-base font-semibold text-secondary">🥇 最佳連號數 / 🎯 最差連號數</h4>
                        <p class="text-xl font-extrabold text-primary">${comboStats.bestConsecutive} 組 <span class="text-gray-400">/</span> ${comboStats.worstConsecutive} 組</p>
                        <div class="mt-2 text-sm text-gray-400">
                           ${formatComboStats(comboStats.consecutiveDistribution.slice(0, 5))}
                        </div>
                    </div>
                </div>
            `;
            
            // 預測結果區塊渲染
            document.getElementById('prediction-results').innerHTML = predictions.map(p => {
                const colors = { 
                    'secondary': 'border-secondary/70 bg-secondary/10', 'primary': 'border-primary/70 bg-primary/10', 'extreme': 'border-extreme/70 bg-extreme/10', 
                    'ai': 'border-ai/70 bg-ai/10', 'genius': 'border-genius/70 bg-genius/10', 'markov': 'border-markov/70 bg-markov/10',
                };
                const hoverEffects = { 
                    'secondary': 'hover:shadow-secondary/30', 'primary': 'hover:shadow-primary/30', 'extreme': 'hover:shadow-extreme/30', 
                    'ai': 'hover:shadow-ai/30', 'genius': 'hover:shadow-genius/30', 'markov': 'hover:shadow-markov/30',
                };
                
                const titleColor = `text-${p.color}`;
                const borderColor = colors[p.color];
                const hoverShadow = hoverEffects[p.color];
                
                const borderStyle = p.color === 'genius' ? 'border-4 border-double border-genius' : 
                                    p.color === 'markov' ? 'border-l-4 border-r-4 border-markov/70' : 
                                    `border-l-4 ${borderColor}`;


                return `
                    <div class="p-4 rounded-xl shadow-lg transition duration-300 transform hover:scale-[1.03] ${borderStyle} ${hoverShadow}">
                        <div class="flex items-center space-x-2 mb-2">
                            <i data-lucide="${p.icon}" class="w-6 h-6 ${titleColor}"></i>
                            <h3 class="text-xl font-extrabold ${titleColor}">${p.name}</h3>
                        </div>
                        <p class="text-xs text-gray-400 mb-3">${p.subtitle}</p>
                        
                        <div class="flex flex-wrap gap-1.5 mb-3">
                            ${p.numbers.split(', ').map(n => `<span class="lotto-ball main">${n}</span>`).join('')}
                        </div>
                        
                        <p class="text-gray-300 text-sm mb-2">${p.basis}</p>
                        <p class="text-yellow-300 text-xs mt-2 font-mono bg-dark-bg/50 p-1 rounded">${p.metrics}</p>
                        
                        <div class="flex items-center mt-3 pt-3 border-t border-card-bg/50">
                            <span class="text-sm mr-2 text-secondary">特別號:</span>
                            ${p.special.split(', ').map(n => `<span class="lotto-ball special">${n}</span>`).join('')}
                        </div>
                    </div>
                `;
            }).join('');

            // ... (Freq, Weighted, Cooccurrence table rendering remains the same)
            document.getElementById('freq-table').innerHTML = sortedFreq.map(([num, count]) => `
                <div class="flex justify-between items-center p-2 border-b border-card-bg/50">
                    <span class="text-lg font-bold w-1/3 text-secondary">${num.toString().padStart(2, '0')}</span>
                    <span class="w-2/3 text-right">${count} 次</span>
                </div>
            `).join('');

            document.getElementById('weighted-table').innerHTML = sortedWeighted.map(([num, score]) => `
                <div class="flex justify-between items-center p-2 border-b border-card-bg/50">
                    <span class="text-lg font-bold w-1/3 text-primary">${num.toString().padStart(2, '0')}</span>
                    <span class="w-2/3 text-right">${score.toFixed(2)} 分</span>
                </div>
            `).join('');
            
            document.getElementById('cooccurrence-table').innerHTML = sortedCooccurrence.map(([pair, count]) => `
                <div class="flex justify-between items-center p-2 border-b border-card-bg/50">
                    <span class="text-lg font-bold w-1/3 text-secondary">${pair}</span>
                    <span class="w-2/3 text-right">${count} 次</span>
                </div>
            `).join('');
            
            // 歷史紀錄表格呈現 (保持表格內編輯)
            document.getElementById('history-table').innerHTML = records.map(r => {
                const year = new Date().getFullYear(); 
                const dateISO = `${year}-${r.date.split('/')[0].padStart(2, '0')}-${r.date.split('/')[1].padStart(2, '0')}`;
                
                if (currentEditingId === r.drawId) {
                    return `
                        <tr id="row-${r.drawId}" class="bg-card-bg/80 border-b border-primary/50">
                            <td class="px-2 py-1 text-primary text-sm font-semibold">${r.drawId}</td>
                            <td class="px-2 py-1">
                                <input type="date" value="${dateISO}" id="edit-date-${r.drawId}" class="inline-edit-input">
                            </td>
                            <td class="px-2 py-1">
                                <input type="text" value="${r.main.map(n => n.toString().padStart(2, '0')).join(', ')}" id="edit-main-${r.drawId}" class="inline-edit-input">
                            </td>
                            <td class="px-2 py-1">
                                <input type="number" min="1" max="49" value="${r.special}" id="edit-special-${r.drawId}" class="inline-edit-input text-center">
                            </td>
                            <td class="px-2 py-1 text-center flex justify-center space-x-2">
                                <button onclick="saveEdit('${r.drawId}')" class="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded transition duration-150">儲存</button>
                                <button onclick="cancelEdit()" class="bg-gray-600 hover:bg-gray-700 text-white text-xs font-bold py-1 px-2 rounded transition duration-150">取消</button>
                            </td>
                        </tr>
                    `;
                }
                
                return `
                    <tr id="row-${r.drawId}" class="border-b border-card-bg/50 hover:bg-card-bg/70">
                        <td class="px-4 py-2 text-primary text-sm font-semibold">${r.drawId || 'N/A'}</td>
                        <td class="px-4 py-2 text-secondary">${r.date}</td>
                        <td class="px-4 py-2 text-center text-gray-200">${r.main.map(n => n.toString().padStart(2, '0')).join(', ')}</td>
                        <td class="px-4 py-2 text-center">
                            <span class="lotto-ball special">${r.special.toString().padStart(2, '0')}</span>
                        </td>
                        <td class="px-4 py-2 text-center flex justify-center space-x-2">
                            <button onclick="startEdit('${r.drawId}')" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-2 rounded transition duration-150">編輯</button>
                            <button onclick="deleteRecord('${r.drawId}')" class="bg-red-600 hover:bg-red-700 text-white text-xs font-bold py-1 px-2 rounded transition duration-150">刪除</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        // --- 回溯測試函數 (保持與前版相同) ---

        function fillBacktestSelector() {
            const selector = document.getElementById('backtest-selector');
            selector.innerHTML = '<option value="" disabled selected>--- 選擇要回溯的期別 ---</option>';
            
            // 排除最新一期 (因為我們需要至少一筆紀錄來計算)
            const availableRecords = dataStore.slice(1); 
            
            if (availableRecords.length < 2) {
                selector.innerHTML = '<option value="" disabled selected>紀錄不足 (需至少 2 期)</option>';
                return;
            }

            // 填充選項
            availableRecords.forEach(record => {
                const option = document.createElement('option');
                option.value = record.drawId;
                option.textContent = `期別 ${record.drawId} (${record.date})`;
                selector.appendChild(option);
            });
        }

        async function runBacktest() {
            const selector = document.getElementById('backtest-selector');
            const drawId = selector.value;
            const resultsDiv = document.getElementById('backtest-results');
            resultsDiv.innerHTML = `<p class="text-center text-ai/80 mt-4"><i data-lucide="Loader" class="w-5 h-5 inline-block animate-spin mr-2"></i>正在進行回溯測試...</p>`;
            lucide.createIcons();

            if (!drawId) {
                resultsDiv.innerHTML = `<p class="text-red-400 mt-4 text-center">❌ 請選擇一個期別進行回溯測試。</p>`;
                return;
            }

            // 找到該期別在 dataStore 中的索引
            const targetIndex = dataStore.findIndex(r => r.drawId === drawId);
            if (targetIndex === -1) {
                resultsDiv.innerHTML = `<p class="text-red-400 mt-4 text-center">❌ 找不到該期紀錄。</p>`;
                return;
            }
            
            // 實際開獎號碼 (Target)
            const actualDraw = dataStore[targetIndex];
            const actualNumbers = new Set(actualDraw.main);

            // 訓練數據集：只使用該期之前的所有紀錄
            const trainingData = dataStore.slice(targetIndex + 1); 

            if (trainingData.length < 5) {
                resultsDiv.innerHTML = `<p class="text-red-400 mt-4 text-center">❌ 訓練數據不足 (至少需要 5 期歷史數據)。</p>`;
                return;
            }

            // 運行分析 (用訓練數據)
            const analysis = runAnalysis(trainingData);
            if (!analysis.sortedFreq) {
                resultsDiv.innerHTML = `<p class="text-red-400 mt-4 text-center">❌ 訓練數據格式錯誤，無法計算分析指標。</p>`;
                return;
            }
            
            // 運行預測 (用訓練數據的指標)
            const predictedStrategies = generatePredictions(analysis);
            
            // 進行比對與評分
            const comparisonResults = predictedStrategies.map(strategy => {
                const predictedNumbers = new Set(strategy.numbers.split(', ').map(s => parseInt(s)));
                let hitCount = 0;
                let specialHit = false; 

                // 主號命中數
                predictedNumbers.forEach(num => {
                    if (actualNumbers.has(num)) {
                        hitCount++;
                    }
                });

                // 特別號命中 (我們只比對主號，但可額外計算特別號)
                const specialCandidates = strategy.special.split(', ').map(s => parseInt(s));
                if (specialCandidates.includes(actualDraw.special)) {
                    specialHit = true;
                }

                // 計算策略傾向命中 (奇偶比)
                const predictedOdd = strategy.numbers.split(', ').map(n => parseInt(n)).filter(n => n % 2 !== 0).length;
                const actualOdd = actualDraw.main.filter(n => n % 2 !== 0).length;
                const parityMatch = predictedOdd === actualOdd;

                return {
                    ...strategy,
                    hitCount: hitCount,
                    specialHit: specialHit,
                    parityMatch: parityMatch,
                    predictedNumbers: Array.from(predictedNumbers).sort((a, b) => a - b)
                };
            }).sort((a, b) => b.hitCount - a.hitCount); // 依命中數降序排列

            // 渲染比對結果
            renderBacktestResults(actualDraw, comparisonResults);
            lucide.createIcons();
        }
        
        function renderBacktestResults(actualDraw, comparisonResults) {
            const resultsDiv = document.getElementById('backtest-results');

            const actualBalls = actualDraw.main.map(n => `<span class="lotto-ball main">${n.toString().padStart(2, '0')}</span>`).join('');
            const specialBall = `<span class="lotto-ball special">${actualDraw.special.toString().padStart(2, '0')}</span>`;

            const rankStyle = (index) => {
                if (index === 0) return 'bg-markov/70 text-dark-bg font-extrabold shadow-xl';
                if (index === 1) return 'bg-secondary/70 text-dark-bg font-bold shadow-lg';
                if (index === 2) return 'bg-gray-500 text-white font-bold shadow-md';
                return 'bg-card-bg/50 text-gray-400';
            };

            const hitStyle = (count) => {
                if (count >= 3) return 'text-extreme font-extrabold text-xl animate-pulse';
                if (count >= 1) return 'text-secondary font-bold';
                return 'text-gray-400';
            };
            
            const renderPredictedBalls = (predicted, actual) => {
                const actualSet = new Set(actual);
                return predicted.map(n => {
                    const hit = actualSet.has(n);
                    const baseClasses = "lotto-ball";
                    const hitClasses = hit ? 'bg-green-600 text-white border-green-700' : 'main'; 
                    return `<span class="${baseClasses} ${hitClasses}">${n.toString().padStart(2, '0')}</span>`;
                }).join('');
            };


            resultsDiv.innerHTML = `
                <div class="mt-6 p-4 rounded-xl shadow-2xl bg-card-bg/80 border-b-4 border-primary">
                    <h3 class="text-2xl font-extrabold text-primary mb-3">🔥 實際開獎結果 (期別 ${actualDraw.drawId})</h3>
                    <div class="flex flex-wrap items-center gap-2">
                        ${actualBalls}
                        <i data-lucide="Plus" class="w-6 h-6 text-primary"></i>
                        ${specialBall}
                    </div>
                </div>

                <div class="mt-6 overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-700">
                        <thead class="bg-dark-bg sticky top-0">
                            <tr>
                                <th class="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase">排名</th>
                                <th class="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase">策略</th>
                                <th class="py-3 px-4 text-center text-sm font-medium text-gray-300 uppercase">命中主號數 (Max 6)</th>
                                <th class="py-3 px-4 text-left text-sm font-medium text-gray-300 uppercase min-w-[300px]">預測號碼組 (命中標記)</th>
                                <th class="py-3 px-4 text-center text-sm font-medium text-gray-300 uppercase">奇偶比一致</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-700">
                            ${comparisonResults.map((r, index) => `
                                <tr class="hover:bg-card-bg/70 ${rankStyle(index)}">
                                    <td class="py-3 px-4 text-center font-bold">${index + 1}</td>
                                    <td class="py-3 px-4 flex items-center space-x-2">
                                        <i data-lucide="${r.icon}" class="w-5 h-5 text-${r.color}"></i>
                                        <span class="font-bold">${r.name.replace('策略一：', '').replace('策略二：', '').replace('策略三：', '').replace('策略四：', '').replace('策略五：', '')}</span>
                                    </td>
                                    <td class="py-3 px-4 text-center ${hitStyle(r.hitCount)}">${r.hitCount} 個</td>
                                    <td class="py-3 px-4">
                                        <div class="flex flex-wrap gap-1">
                                            ${renderPredictedBalls(r.predictedNumbers, actualDraw.main)}
                                        </div>
                                    </td>
                                    <td class="py-3 px-4 text-center">
                                        <i data-lucide="${r.parityMatch ? 'CheckCircle' : 'XCircle'}" class="w-5 h-5 ${r.parityMatch ? 'text-green-500' : 'text-red-500'} inline-block"></i>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        
        // --- 輔助/CRUD/I/O 函數 (保持與前版相同) ---
        window.startEdit = (drawId) => {
            currentEditingId = drawId;
            processAndRenderData(dataStore);
        }

        window.cancelEdit = () => {
            currentEditingId = null;
            processAndRenderData(dataStore);
        }

        window.saveEdit = async (drawId) => {
            const dateInput = document.getElementById(`edit-date-${drawId}`).value;
            const mainInput = document.getElementById(`edit-main-${drawId}`).value;
            const specialInput = document.getElementById(`edit-special-${drawId}`).value;
            const messageEl = document.getElementById('form-message');

            const mainNumbers = mainInput.split(/[,\s]+/) 
                .map(s => parseInt(s.trim()))
                .filter(n => !isNaN(n) && n >= 1 && n <= 49); 
            const specialNumber = parseInt(specialInput.trim());

            const allNums = [...mainNumbers, specialNumber];
            if (!dateInput || mainNumbers.length !== 6 || isNaN(specialNumber) || mainNumbers.includes(specialNumber) || 
                (new Set(allNums)).size !== 7 || allNums.some(n => n < 1 || n > 49 || isNaN(n))) {
                messageEl.textContent = '❌ 編輯失敗：請檢查號碼格式、數量或重複性。';
                messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                messageEl.classList.remove('hidden');
                return;
            }

            try {
                const dateParts = dateInput.split('-');
                const docDate = `${dateParts[1].padStart(2, '0')}/${dateParts[2].padStart(2, '0')}`;

                const updatedRecord = {
                    drawId: drawId,
                    date: docDate, 
                    main: mainNumbers.sort((a, b) => a - b),
                    special: specialNumber
                };

                await writeRecordToFirestore(updatedRecord);
                
                messageEl.textContent = `✅ 期別 ${drawId} 紀錄修改成功，分析數據已自動更新！`;
                messageEl.classList.add('text-green-500', 'p-2', 'rounded-lg', 'bg-green-900/50');
                messageEl.classList.remove('hidden');

                currentEditingId = null; 
            } catch (error) {
                console.error("儲存編輯失敗: ", error);
                messageEl.textContent = `❌ 儲存編輯失敗 (Firestore 錯誤): ${error.message}.`;
                messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                messageEl.classList.remove('hidden');
            }
        }
        
        async function writeRecordToFirestore(record) {
            if (!db) throw new Error("Firestore 尚未初始化或權限不足。");
            
            const docRef = doc(db, COLLECTION_PATH, record.drawId);
            
            await setDoc(docRef, {
                drawId: record.drawId,
                date: record.date,
                main: record.main,
                special: record.special,
                timestamp: serverTimestamp() 
            }, { merge: true }); 
        }
        
        async function deleteRecordFromFirestore(drawId) {
            if (!db) throw new Error("Firestore 尚未初始化或權限不足。");
            
            const docRef = doc(db, COLLECTION_PATH, drawId);
            await deleteDoc(docRef);
        }

        async function handleAddResult(e) {
            e.preventDefault();
            const messageEl = document.getElementById('form-message');
            messageEl.classList.remove('hidden', 'text-red-500', 'bg-red-900/50', 'text-yellow-500', 'bg-yellow-900/50', 'text-green-500', 'bg-green-900/50', 'p-2', 'rounded-lg');
            
            const drawIdInput = document.getElementById('draw-id').value.trim(); 
            const dateInput = document.getElementById('draw-date').value; 
            const mainInput = document.getElementById('main-numbers').value;
            const specialInput = document.getElementById('special-number').value;

            if (!drawIdInput) {
                 messageEl.textContent = '❌ 請輸入「期別」欄位。';
                messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                return;
            }

            const mainNumbers = mainInput.split(/[,\s]+/) 
                .map(s => parseInt(s.trim()))
                .filter(n => !isNaN(n) && n >= 1 && n <= 49); 
            const specialNumber = parseInt(specialInput.trim());

            const allNums = [...mainNumbers, specialNumber];
            if (!dateInput || mainNumbers.length !== 6 || isNaN(specialNumber) || mainNumbers.includes(specialNumber) || 
                (new Set(allNums)).size !== 7 || allNums.some(n => n < 1 || n > 49 || isNaN(n))) {
                messageEl.textContent = '❌ 請檢查輸入：日期、6個主號（不重複）和1個特別號（不與主號重複），且號碼介於 01-49。';
                messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                return;
            }
            
            const isExistByDrawId = dataStore.some(record => record.drawId === drawIdInput);
            if (isExistByDrawId) {
                messageEl.textContent = `❌ 錯誤：「期別」 ${drawIdInput} 的紀錄已存在。請使用下方表格的「編輯」功能進行修改。`;
                messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                return;
            }

            try {
                const dateParts = dateInput.split('-');
                const docDate = `${dateParts[1].padStart(2, '0')}/${dateParts[2].padStart(2, '0')}`;
                
                const newRecord = {
                    drawId: drawIdInput,
                    date: docDate, 
                    main: mainNumbers.sort((a, b) => a - b),
                    special: specialNumber
                };

                await writeRecordToFirestore(newRecord);
                
                messageEl.textContent = `✅ 期別 ${drawIdInput} 紀錄新增成功，分析數據已自動更新！`;
                messageEl.classList.add('text-green-500', 'p-2', 'rounded-lg', 'bg-green-900/50');
                e.target.reset(); 
                
            } catch (error) {
                console.error("寫入 Firestore 失敗: ", error);
                messageEl.textContent = `❌ 新增紀錄失敗 (Firestore 錯誤): ${error.message}. 請檢查您的 Firebase 權限。`;
                messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
            }
        }
        
        window.deleteRecord = (drawId) => {
            renderModal({
                title: '確認刪除紀錄',
                content: `您確定要刪除期別 **${drawId}** 的開獎紀錄嗎？此操作不可逆。`,
                confirmText: '確認刪除',
                onConfirm: async () => {
                    const messageEl = document.getElementById('form-message');
                    try {
                        await deleteRecordFromFirestore(drawId);
                        messageEl.textContent = `✅ 期別 ${drawId} 紀錄已成功刪除。`;
                        messageEl.classList.add('text-green-500', 'p-2', 'rounded-lg', 'bg-green-900/50');
                    } catch (error) {
                        messageEl.textContent = `❌ 刪除紀錄失敗 (Firestore 錯誤): ${error.message}`;
                        messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                    }
                    messageEl.classList.remove('hidden');
                    closeModal();
                }
            });
        }
        
        function renderModal({ title, content, confirmText, onConfirm }) {
            const modalContainer = document.getElementById('modal-container');
            modalContainer.innerHTML = `
                <div id="custom-modal" class="fixed inset-0 bg-dark-bg/80 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                    <div class="bg-card-bg p-6 rounded-xl shadow-2xl max-w-sm w-full border border-primary/50">
                        <h3 class="text-xl font-bold text-white mb-4 border-b border-primary/50 pb-2">${title}</h3>
                        <p class="text-gray-300 mb-6">${content.replace(/\*\*/g, '<strong>').replace(/\*\*/g, '</strong>')}</p>
                        <div class="flex justify-end space-x-3">
                            <button id="modal-cancel-btn" class="py-2 px-4 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition duration-200">取消</button>
                            <button id="modal-confirm-btn" class="py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition duration-200">${confirmText}</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('modal-cancel-btn').onclick = closeModal;
            document.getElementById('modal-confirm-btn').onclick = onConfirm;
            modalContainer.classList.remove('hidden');
        }

        window.closeModal = () => {
            document.getElementById('modal-container').classList.add('hidden');
            document.getElementById('modal-container').innerHTML = '';
        }

        function exportData() {
            const dataForExcel = dataStore.map(record => ({
                '期別': record.drawId || '', 
                '日期': record.date, 
                '主號': record.main.map(n => n.toString().padStart(2, '0')).join(', '),
                '特別號': record.special.toString().padStart(2, '0')
            }));

            const ws = XLSX.utils.json_to_sheet(dataForExcel);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "大樂透紀錄");

            const filename = '大樂透歷史紀錄_Firestore.xlsx';
            XLSX.writeFile(wb, filename);

            const messageEl = document.getElementById('form-message');
            messageEl.textContent = `✅ 資料已匯出為 ${filename} 檔案！`;
            messageEl.classList.remove('hidden', 'text-red-500', 'bg-red-900/50', 'text-yellow-500', 'bg-yellow-900/50');
            messageEl.classList.add('text-green-500', 'p-2', 'rounded-lg', 'bg-green-900/50');
        }

        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            const messageEl = document.getElementById('form-message');
            messageEl.classList.remove('hidden', 'text-red-500', 'bg-red-900/50', 'text-yellow-500', 'bg-yellow-900/50', 'text-green-500', 'bg-green-900/50', 'p-2', 'rounded-lg');

            reader.onload = async function(event) {
                let newRecords = [];
                try {
                    const data = new Uint8Array(event.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheet = workbook.Sheets[workbook.SheetNames[0]];
                    const importedJson = XLSX.utils.sheet_to_json(sheet);
                    
                    if (!Array.isArray(importedJson) || importedJson.length === 0) throw new Error("匯入的檔案無有效數據。");
                    
                    importedJson.forEach((row, index) => {
                        const drawId = row['期別'] ? row['期別'].toString() : null; 
                        const special = parseInt(row['特別號']);
                        const dateRaw = row['開獎日期'] || row['日期']; 
                        
                        if (!drawId || !dateRaw || isNaN(special)) return; 
                        
                        let mainNums = [];
                        if (row['主號']) {
                            mainNums = row['主號'].toString().split(/[,\s]+/) 
                                .map(s => parseInt(s.trim()))
                                .filter(n => !isNaN(n) && n >= 1 && n <= 49); 
                        } else {
                            for (let i = 1; i <= 6; i++) {
                                const numKey = `獎號${i}`;
                                const num = parseInt(row[numKey]);
                                if (!isNaN(num) && num >= 1 && num <= 49) {
                                    mainNums.push(num);
                                }
                            }
                        }
                        
                        if (mainNums.length !== 6 || mainNums.includes(special) || (new Set(mainNums)).size !== 6) {
                             throw new Error(`第 ${index + 1} 行數據格式錯誤：主號數量或規則不符。`);
                        }
                        
                        let formattedDate = dateRaw.toString();
                        if (typeof dateRaw === 'number') {
                            const date = XLSX.SSF.parse_date_code(dateRaw);
                            formattedDate = `${(date.m).toString().padStart(2, '0')}/${(date.d).toString().padStart(2, '0')}`;
                        } else {
                            const dateParts = formattedDate.match(/(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
                            if (dateParts) {
                                formattedDate = `${dateParts[2].padStart(2, '0')}/${dateParts[3].padStart(2, '0')}`;
                            } else {
                                formattedDate = formattedDate.replace(/\//g, '/').replace(/-/g, '/');
                            }
                        }

                        newRecords.push({
                            drawId: drawId,
                            date: formattedDate, 
                            main: mainNums.sort((a, b) => a - b),
                            special: special
                        });
                    });

                    if (newRecords.length === 0) throw new Error("匯入檔案中找不到有效且格式正確的開獎紀錄。請檢查標頭名稱是否正確。");

                    const batch = writeBatch(db);
                    let importedCount = 0;
                    
                    for (const record of newRecords) {
                        if (!dataStore.some(r => r.drawId === record.drawId)) {
                             const docRef = doc(db, COLLECTION_PATH, record.drawId);
                             batch.set(docRef, { ...record, timestamp: serverTimestamp() });
                             importedCount++;
                        }
                    }

                    if (importedCount > 0) {
                        await batch.commit();
                        messageEl.textContent = `✅ 成功匯入 ${importedCount} 筆新紀錄！分析數據已自動更新。`;
                        messageEl.classList.add('text-green-500', 'p-2', 'rounded-lg', 'bg-green-900/50');
                    } else {
                        messageEl.textContent = `⚠️ 警告：所有紀錄的期別都已存在於數據庫中，未寫入任何新紀錄。`;
                        messageEl.classList.add('text-yellow-500', 'p-2', 'rounded-lg', 'bg-yellow-900/50');
                    }

                } catch (error) {
                    console.error("Import failed:", error);
                    messageEl.textContent = `❌ 匯入失敗 (寫入錯誤)：${error.message || '請確保檔案格式正確。'}`;
                    messageEl.classList.add('text-red-500', 'p-2', 'rounded-lg', 'bg-red-900/50');
                } finally {
                    e.target.value = ''; 
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // --- 啟動程序 ---
        document.addEventListener('DOMContentLoaded', initializeFirebase);
    </script>
    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #374151; }
        ::-webkit-scrollbar-thumb { background: #DC2626; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #B91C1C; }
        /* Lotto ball styling */
        .lotto-ball {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-weight: bold;
            color: #1F2937;
            font-size: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -2px rgba(0, 0, 0, 0.5);
            border: 2px solid;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        .lotto-ball.main {
            background: linear-gradient(145deg, #FFEFBA, #FFD700); /* Golden color for main */
            border-color: #DAA520;
        }
        .lotto-ball.special {
            background: linear-gradient(145deg, #FF6B6B, #DC2626); /* Red color for special */
            color: white;
            border-color: #991B1B;
        }
        .lotto-ball:hover {
            transform: scale(1.05);
        }
        /* Style for inline edit inputs */
        .inline-edit-input {
            width: 100%;
            padding: 4px;
            border-radius: 4px;
            background-color: #1F2937;
            border: 1px solid #60A5FA;
            color: white;
            font-size: 12px;
            -webkit-appearance: none; 
            appearance: none;
        }
        /* Media Queries for Responsive Grid */
        @media (max-width: 768px) {
            .lotto-ball {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            .table-responsive td { white-space: nowrap; }
            .inline-edit-input {
                font-size: 10px;
                padding: 3px;
            }
            #prediction-results { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        }
        @media (min-width: 768px) {
            #prediction-results { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        }
        @media (min-width: 1024px) {
            #prediction-results { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        @media (min-width: 1280px) {
            #prediction-results { grid-template-columns: repeat(5, minmax(0, 1fr)); }
        }

    </style>
</head>
<body class="bg-dark-bg text-gray-100 min-h-screen p-4 font-sans antialiased">
    <!-- Modal Container -->
    <div id="modal-container" class="hidden"></div>

    <!-- 錯誤顯示區塊 -->
    <div id="error-display" class="hidden"></div>
    
    <!-- 頁面結構 -->
    <div class="max-w-7xl mx-auto py-6">

        <header class="text-center mb-8 border-b border-primary pb-4">
            <h1 class="text-4xl md:text-5xl font-extrabold text-white tracking-tight">大樂透分析顧問🧠</h1>
            <p class="text-secondary mt-2 text-lg">歷史數據統計、編輯與下一期候選號碼建議</p>
        </header>

        <!-- 載入指示器 -->
        <div id="loading-indicator" class="flex flex-col justify-center items-center h-64">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-primary"></div>
            <p class="text-white ml-4 text-xl mt-4">Firebase 資料庫連接中，請稍候...</p>
        </div>

        <!-- 主要內容區塊 -->
        <div id="main-content" class="hidden">
            <p id="user-id-display" class="text-sm text-gray-500 mb-4 text-center"></p>

            <!-- 部署提示 (僅供外部平台用戶閱讀) 
            <div class="bg-yellow-900/40 border-l-4 border-yellow-400 p-4 mb-8 rounded-lg text-yellow-100">
                <p class="font-bold text-lg">📢 跨平台部署提示 (務必檢查):</p>
                <ul class="list-disc list-inside mt-2 text-sm space-y-1">
                    <li>請確認您已在程式碼中替換 **`EXTERNAL_FIREBASE_CONFIG`** 變數。</li>
                    <li>請確認 Firebase 專案已啟用 **匿名登入**，且 Firestore 規則允許匿名用戶讀寫。</li>
                </ul>
            </div>
            -->

            <!-- 預測結果區塊 -->
            <section class="mb-8">
                <h2 class="text-3xl font-bold text-white mb-4 border-b border-card-bg pb-2">🎯 AI 多策略分析 </h2>
                <!-- 調整為 5 欄網格 -->
                <div id="prediction-results" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4">
                    <!-- Prediction results will be injected here -->
                </div>
                <p class="text-sm text-gray-400 mt-4 p-3 bg-card-bg rounded-lg">
                    **風險聲明**：彩券本質為隨機獨立抽樣，各期號碼中獎機率相等，歷史開獎數據無法作為未來結果的預測依據。本報告僅為基於歷史資料的數據分析與組合建議，不構成任何投注保證，僅供娛樂參考。
                </p>
            </section>
            
            <!-- 策略回溯測試區塊 -->
            <section class="mb-8 p-6 bg-card-bg rounded-xl shadow-2xl border border-ai/50">
                <h2 class="text-3xl font-bold text-white mb-4 flex items-center space-x-2">
                    <i data-lucide="TestTube" class="w-7 h-7 text-ai"></i>
                    <span>🧪 策略回溯測試 (Backtesting)</span>
                </h2>
                <p class="text-gray-300 mb-4">
                    選擇一期歷史開獎結果，本系統將使用該期之前的數據進行預測，並比對五個策略的命中表現。
                </p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="md:col-span-2">
                        <select id="backtest-selector" class="w-full p-2.5 rounded-lg bg-dark-bg border border-gray-600 text-white focus:ring-ai focus:border-ai">
                            <option value="" disabled selected>--- 選擇要回溯的期別 ---</option>
                        </select>
                    </div>
                    <div>
                        <button id="backtest-run-btn" class="w-full py-2.5 px-4 bg-ai hover:bg-ai/90 text-dark-bg font-bold rounded-lg transition duration-200 shadow-md">
                            運行回溯測試
                        </button>
                    </div>
                </div>

                <div id="backtest-results" class="mt-6">
                    <!-- Backtest results table will be injected here -->
                </div>
            </section>


            <!-- 數據輸入與 I/O 控制 -->
            <section class="mb-8 p-6 bg-card-bg rounded-xl shadow-2xl border border-primary/30">
                <h2 class="text-3xl font-bold text-white mb-4">✍️ 數據管理與更新</h2>
                
                <!-- I/O 按鈕 -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="col-span-1 md:col-span-2">
                        <label for="import-file-input" class="block text-sm font-medium text-gray-300 mb-1">匯入數據 (XLSX/XLS 檔案)</label>
                        <input type="file" id="import-file-input" accept=".xlsx,.xls" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-secondary file:text-dark-bg hover:file:bg-secondary/80">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-1 invisible md:visible">匯出當前數據</label>
                        <button id="export-data-btn" class="w-full py-2 px-4 bg-primary hover:bg-red-700 text-white font-bold rounded-lg transition duration-200 shadow-md">
                            匯出為 XLSX 檔案 (含 Firestore 紀錄)
                        </button>
                    </div>
                </div>

                <!-- 新增紀錄表單 -->
                <h3 class="text-2xl font-semibold text-white border-t border-card-bg/50 pt-4 mb-4">新增開獎號碼</h3>
                <form id="add-result-form" class="grid grid-cols-1 md:grid-cols-5 gap-4">
                    <div class="col-span-1">
                        <label for="draw-id" class="block text-sm font-medium text-gray-300 mb-1">期別 (Draw ID) <span class="text-primary">*</span></label>
                        <input type="text" id="draw-id" required placeholder="例如: 114000092" class="w-full p-2 rounded-lg bg-dark-bg border border-gray-600 text-white focus:ring-primary focus:border-primary">
                    </div>
                    <div class="col-span-1">
                        <label for="draw-date" class="block text-sm font-medium text-gray-300 mb-1">開獎日期 (西元) <span class="text-primary">*</span></label>
                        <input type="date" id="draw-date" required class="w-full p-2 rounded-lg bg-dark-bg border border-gray-600 text-white focus:ring-primary focus:border-primary">
                    </div>
                    <div class="col-span-2">
                        <label for="main-numbers" class="block text-sm font-medium text-gray-300 mb-1">主號 (6個, 貼上空格或逗號分隔) <span class="text-primary">*</span></label>
                        <input type="text" id="main-numbers" required placeholder="例如: 01 07 14 22 33 45" class="w-full p-2 rounded-lg bg-dark-bg border border-gray-600 text-white focus:ring-primary focus:border-primary">
                    </div>
                    <div class="col-span-1">
                        <label for="special-number" class="block text-sm font-medium text-gray-300 mb-1">特別號 <span class="text-primary">*</span></label>
                        <input type="number" id="special-number" min="1" max="49" required class="w-full p-2 rounded-lg bg-dark-bg border border-gray-600 text-white focus:ring-primary focus:border-primary">
                    </div>
                    <div class="md:col-span-5">
                        <button type="submit" id="submit-btn" class="w-full py-2 px-4 bg-primary hover:bg-red-700 text-white font-bold rounded-lg transition duration-200 shadow-md transform hover:scale-[1.01]">
                            新增並寫入 Firestore
                        </button>
                    </div>
                </form>
                <p id="form-message" class="mt-3 text-center hidden"></p>
            </section>

            <!-- 統計數據呈現 -->
            <section class="mb-8">
                <h2 class="text-3xl font-bold text-white mb-4 border-b border-card-bg pb-2">📊 核心統計分析 (Top 10)</h2>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                    <!-- 總體頻率 -->
                    <div class="bg-card-bg p-4 rounded-xl shadow-lg">
                        <h3 class="text-xl font-semibold text-secondary mb-3">總體出號頻率</h3>
                        <div id="freq-table" class="space-y-1">
                            <!-- Freq data here -->
                        </div>
                    </div>
                    <!-- 近期加權頻率 -->
                    <div class="bg-card-bg p-4 rounded-xl shadow-lg">
                        <h3 class="text-xl font-semibold text-primary mb-3">近期加權熱門號</h3>
                        <div id="weighted-table" class="space-y-1">
                            <!-- Weighted data here -->
                        </div>
                    </div>
                    <!-- 高共現對 -->
                    <div class="bg-card-bg p-4 rounded-xl shadow-lg">
                        <h3 class="text-xl font-semibold text-secondary mb-3">高共現對 (主號)</h3>
                        <div id="cooccurrence-table" class="space-y-1">
                            <!-- Cooccurrence data here -->
                        </div>
                    </div>
                    <!-- 組合傾向 (新增) -->
                    <div class="bg-card-bg p-4 rounded-xl shadow-lg">
                        <h3 class="text-xl font-semibold text-primary mb-3">📈 歷史組合傾向</h3>
                        <div id="combo-stats" class="space-y-1">
                            <!-- Combination stats here -->
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- 歷史紀錄 (增強呈現) -->
            <section>
                <h2 class="text-3xl font-bold text-white mb-4 border-b border-card-bg pb-2">📜 歷史開獎紀錄</h2>
                <div class="bg-card-bg rounded-xl shadow-lg overflow-x-auto max-h-96">
                    <table class="min-w-full divide-y divide-gray-700">
                        <thead class="bg-dark-bg sticky top-0">
                            <tr>
                                <th class="px-4 py-3 text-left text-sm font-medium text-gray-300 uppercase tracking-wider">期別</th>
                                <th class="px-4 py-3 text-left text-sm font-medium text-gray-300 uppercase tracking-wider min-w-[120px]">日期</th>
                                <th class="px-4 py-3 text-center text-sm font-medium text-gray-300 uppercase tracking-wider min-w-[180px]">主號 (6個)</th>
                                <th class="px-4 py-3 text-center text-sm font-medium text-gray-300 uppercase tracking-wider min-w-[60px]">特別號</th>
                                <th class="px-4 py-3 text-center text-sm font-medium text-gray-300 uppercase tracking-wider min-w-[120px]">操作</th>
                            </tr>
                        </thead>
                        <tbody id="history-table" class="divide-y divide-gray-700">
                            <!-- History data will be injected here -->
                        </tbody>
                    </table>
                </div>
            </section>

        </div>
    </div>
</body>
</html>

